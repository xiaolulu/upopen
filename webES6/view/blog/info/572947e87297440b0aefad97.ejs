<% include ../../common/header.ejs %> <div class="main" id="blogBox"><section><div class="info clearfix"><span class="title">NODEJS项目实践0.5 - 完结[inspector,git]</span> <a class="type" href="/blog/list?kind=nodejs">nodejs</a> <img class="head" src="/public/imgs/head.png" width="42"></div><div class="tool"><!--span class="toolItem view">Views: 0</span>
			<span class="toolItem talk">Comments: 0</span--> <span class="toolItem date">Date: 2016-05-03</span></div><div class="content clearfix markdown"><h3 id="-">一、前言</h3><p>上节我们主要应用了部分nodejs模块功能，本节我们再演示下nodejs常用的debug功能，git使用，并发布到阿里云，就完成了 0.*系统的教程。</p><p>GIT：<a href="https://github.com/xiaolulu/mynodejs.git">https://github.com/xiaolulu/mynodejs.git</a></p><p>参考：<a href="http://www.upopen.cn">http://www.upopen.cn</a></p><h3 id="-">二、调试模块</h3><p>debug，即开发过程中的运行跟踪，是开发过程中的不可缺少的。如同页面端开发过程中，如果没有chrome的inspect element，开发过程中的问题排查，将是非常困难的。</p><p>⋅⋅⋅nodejs目前常用的有两种类型的调试方案</p><p>⋅⋅⋅1、以 webstorm为代表的开发编辑器类调试。webstrom本身支持很好的nodejs的开发体验，其也集成了测试功能，但这个不是我推荐的，自行百度 “ webstorm nodejs 调试 ”。</p><p>⋅⋅⋅2、第二种是npm 下的 node-inspector，我使用的编辑器就是ubuntu下的gedit，即使在win7下使用的也是较古老的 edit plus，因为开发过程中，不需要什么提示功能，webstorm本身很大，启动起来也占用很大的资源。相比之下，gedit + node-inspector，则更加轻量。</p><p>⋅⋅⋅全局安装：</p><pre><code>npm install -g node-inspector
</code></pre><p>⋅⋅⋅启动</p><p>⋅⋅⋅ssh执行</p><pre><code>node-inspector
</code></pre><p>⋅⋅⋅会提示</p><pre><code>Visit http://127.0.0.1:8080/?ws=127.0.0.1:8080&amp;port=5858 to start debugging.
</code></pre><p>⋅⋅⋅再开一个终端，cd到项目目录，执行</p><pre><code>node-dev –debug app.js
</code></pre><p>⋅⋅⋅上一节我们讲node-dev，使用了其自动 restarting，如果不需要高度，执行 node-dev app.js即可。</p><p>⋅⋅⋅浏览器A打开</p><pre><code>http://127.0.0.1:8080/?ws=127.0.0.1:8080&amp;port=5858
</code></pre><p>⋅⋅⋅浏览器A即会显示成debug模式，</p><p>⋅⋅⋅再用浏览器B打开我们项目，浏览器A就会显示nodejs端的代码，调用起来和页面端一样一样的。所以用 node-inspector可以安装后即可快速上手，不需要任何配置，使用起来不需额外成本，这也是我推荐的原因。</p><p>⋅⋅⋅如下图：</p><p><img src="http://upopen.cn/upload/nodejs/20150807001.png" alt="alt text" title="Logo Title Text 2"></p><h3 id="-git">三、git</h3><p>⋅⋅⋅git的常用命令可参见</p><pre><code>http://www.upopen.cn/article/list?kind=git
</code></pre><p>⋅⋅⋅参照上面的教程，在 github上申请账号、新建项目、添加本地生成的key之后，就可以开始使用了。</p><p>⋅⋅⋅cd到我们的项目 root，执行</p><pre><code>git init    
</code></pre><p>⋅⋅⋅将本地文件夹初即化为 git目录，通过 ls -la，可以看到其下多了.ssh的隐藏文件夹，用于存放git信息</p><p>⋅⋅⋅执行</p><pre><code>git remote add origin git@github.com:&lt;your-github&gt;/&lt;your-project&gt;.git
</code></pre><p>⋅⋅⋅将本地目录和远程目录关联起来</p><pre><code>git config -- global user.name &lt;your name&gt;

git config – global user.email &lt;your email&gt; 
</code></pre><p>⋅⋅⋅配置自己的git信息，用于提交的记录author。</p><pre><code>git add *
</code></pre><p>⋅⋅⋅添加所有的文件到暂存区</p><pre><code>git commit -m &#39;我的第一个项目&#39;
</code></pre><p>⋅⋅⋅将暂存区的文件提交到 git 目录</p><pre><code>git push -u origin master
</code></pre><p>⋅⋅⋅按提示输入你的git帐号及密码，将git 目录的文件提交到远程github上</p><p>⋅⋅⋅我们即完成了本地代码的提交，具体命令解释及更多命令应用还是参照</p><p>⋅⋅⋅<a href="http://www.upopen.cn/article/list?kind=git">http://www.upopen.cn/article/list?kind=git</a></p><h3 id="-">四、服务器</h3><p>⋅⋅⋅此处我使用的阿里云服务器，管理上简单些，选了个最低配置，1000/年，www.upopen.cn就是在阿里云上，七牛，百度也提供了这样的服务器。购买好服务器后，选择安装ubuntu系统。</p><p>⋅⋅⋅连接服务器</p><pre><code>ssh &lt;you server ip&gt; -l root
</code></pre><p>⋅⋅⋅用户名先默认用 root即可。按提示输入密码即可登录</p><p>⋅⋅⋅按项目约定安装，nginx / nodejs / mongo / git 等，并创建根目录</p><p>⋅⋅⋅克隆远程库到本地</p><pre><code>git clone root git@github.com:xiaolulu/mynodejs.git
</code></pre><p>⋅⋅⋅拉取远程库的数据到本地</p><pre><code>git pull origin master
</code></pre><p>⋅⋅⋅在此我们使用了与上面git不同的命令，其实也可以按init/ remote来，为了多使用几个命令，另外，第三 部分是新建库，此部主要是拉取。对后面的使用是一样的。</p><p>⋅⋅⋅同样的配置成功后，访问该你的服务器IP，站点即发布成功。</p><p>⋅⋅⋅如果有域名了更好，不过域名现在都需要备案了，需要些时间。</p><h3 id="-validate-js">五、validate.js</h3><p>⋅⋅⋅最后稍讲下页面端的js，原本不是我们本系列的重点，和大家探讨下，如何写一个可复用、解耦的组件，小微框架的思想也不过如此。</p><p>⋅⋅⋅验证组件有很多种写法，但往往越高级的，限制性越大，我们写一个轻量级的，抛砖引玉。</p><p>⋅⋅⋅首先我们分析下验证功能，得出以下一些原则</p><p>⋅⋅⋅1、每个输入项都可以配置验证规则</p><p>⋅⋅⋅2、可指定触发事件，如keyup或 change时触发验证</p><p>⋅⋅⋅3、可配置一些通用的规则如非空、最小值、最大值、只能输入数字、字母、电话、身份证等</p><p>⋅⋅⋅4、可配置自定义规则，如注册时，再次输入密码项的规则和密码项需一致。</p><p>⋅⋅⋅5、提供错误提示的回调，往往错误提示形式是一致的，不需要提供回调，我们提供更自由的显示方式。</p><p>⋅⋅⋅以注册页面表单为例，定义输入框的规则。在root/static/module/issue/register.js下新增</p><pre><code class="lang-js">    var username = $( &#39;#username&#39; ),
        password = $( &#39;#password&#39; ),
        email = $( &#39;#email&#39; );
    //定义验证规则
    var usernameRule = [{
            &#39;noBlank&#39;: &#39;请输入用户名&#39;,    //非空
            &#39;min&#39;: [ 3, &#39;用户名不能少于3位&#39;],    //最小
            &#39;max&#39;: [ 16, &#39;用户名长度不能多于16位&#39;],    //最大
            &#39;typeEN&#39;: &#39;用户名只能为字母及数字&#39;     //准输入类型
        }, function( prompt ){    //错误提示回调
            $( &#39;#usernameTip&#39; ).html( prompt );
        }],
        passwordRule = [{
            &#39;noBlank&#39;: &#39;请输入密码&#39;,
            &#39;self&#39;: function( cb ){    //自定义规则
                cb( &#39;密码不能全为数字&#39; );
                return isNaN( this.value - 0 );
            }
        }],
        email = [{
            &#39;noBlank&#39;: &#39;请输入注册邮箱&#39;,
            &#39;typeEmail&#39;: &#39;邮箱格式不正确&#39;    //指定某定义规则
        }, function( prompt ){
            $( &#39;#emailTip&#39; ).html( prompt );
        }];

    //为指定指定表单添加指定触发事件的指定规则
    validate( username, [ &#39;keyup&#39; ], usernameRule );
    validate( password, [ &#39;change&#39; ], passwordRule );
    validate( email, [ &#39;foucsOut&#39; ], emailRule );
</code></pre><p>⋅⋅⋅在root/static下新建 widget/，用于存放组件。其下新建 validate/validate.js</p><pre><code class="lang-js">define(function(  ){

    var isArray = function( value ){
        return Object.prototype.toString.call( value ) == &#39;[object ]&#39;
    }

    /*定义常用规则，通过判断值是否符合规则返回true / false */
    var Regular = {

        //非空
        noBlank: function( value ){
            return !!value;
        },
        //最小
        min: function( value, rule ){
            return value.length &gt;= rule;
        },
        //最大
        max: function( value, rule ){
            return value.length &lt;= rule;
        },
        //中文、英文
        typeZE: function( value ){
            return /^[\u4E00-\u9FA5\uf900-\ufa2d\uFE30-\uFFA0a-zA-Z]+$/.test( value );
        },
        //英文、数字
        typeEN: function( value ){
            return /^[0-9|a-z|A-Z]+$/.test( value );
        },
        //数字
        typeNum: function( value ){
            return !isNaN( value );
        },
        //电话
        typePhone: function( value ){
            return /^1[0-9]{10}$/.test( value );
        },
        //email
        typeEmail: function( value ){
            return /^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/.test(value)
        }

    }
    //循环对规则进行验证，主要分类两种。一种是self，一种是已定义的常用规则。
    function check( rules, cb ){

        var rule,
            prompt,
            codex,
            value = this.value;
        for ( rule in rules ){

            prompt = rules[ rule ];
            isArray( prompt ) &amp;&amp; ( codex = prompt[0] ) &amp;&amp; ( prompt = prompt[1] );
            //这里是针对 即带值，又带提示的规则 [ 3, &#39;用户名不能少于3位&#39;]
            //否则只带提示的规则，如非空，电话号码等值可定的规则
            if( rule == &#39;self&#39; ){    //验证自定义的定义
                if( rules[ rule ].call( this, cb ) !== true ){
                    return false;
                };
            } else if( !Regular[ rule ]( value, codex ) ){    //验证上面定义过的规则
                cb( prompt )
                return false;
            }
            cb( &#39;&#39; );
        }
        return true;

    }
    //开始的验证函数，对某元素el添加指定事件events的验证规则rules，验证结果在cb中执行
    function validate( el, events, rules, cb ){

        if( rules ){

            cb = rules[1];
            rules = rules[0];
            $.each( events, function( k, event ){
                el.on( event, function(){
                    check.call( this, rules, cb );
                });

            });

        } else {
            //这里是对不用传触发条件，直接进行验证的规则。主要是针对form.submit时需一次验证所有输入框时
            cb = events[1];
            rules = events[0];
            return check.call( el.get( 0 ), rules, cb );

        }

    }

    return validate

})
</code></pre><p>⋅⋅⋅上面是写了一种较初级的验证函数，不过也可以解决大部分的验证场景，常用规则可自行添加。</p><h3 id="-">六、结语</h3><p>⋅⋅⋅至此，除了将数据存取部分和前台分离 及redis外，我们基本完成了0.1中所设定的功能，并应用到所列举的知识点，各知识点都是针对本项目使用了初级的功能。</p><p>⋅⋅⋅简单总结下，前面5节所讲过的知识点：</p><p>⋅⋅⋅1、安装、使用ubuntu，在Linux平台下开发项目，提高开发效率，扩展知识面。</p><p>⋅⋅⋅2、使用nodejs，基于express、ejs框架，实现的基础的静态页面访问</p><p>⋅⋅⋅3、使用nginx，搭建静态服务器，并做了代理转发及负载</p><p>⋅⋅⋅4、据项目优化目录结构，做到分类明晰，静态、项目资源分离，各文件做意义划分，便于后面扩展</p><p>⋅⋅⋅5、使用mongodb，实现了数据的存取，完成注册、登录等操作的客户端 - 服务端的数据交互</p><p>⋅⋅⋅6、页面端使用requireJs来做模块管理并简单实现了验证模块。</p><p>⋅⋅⋅7、使用了npm 的 node-dev[自启动]、md5[加密]、domain[异步异常]、pm2[进程守护]、log4js[服务日志]、node-inspector[开发调试]等模块。</p><p>⋅⋅⋅8、实现了cookie和session的操作，保持用户登录状态</p><p>⋅⋅⋅9、实现据登录状态的页面访问准入控制权限。</p><p>⋅⋅⋅10、git操作，提交到服务器上。</p><p>⋅⋅⋅上面的知识在项目上应用的较初级，后面对每个技术点都会做单独的文章补充，希望对我们都有所帮助，抛砖引玉，大家多做深入研究。</p><p>⋅⋅⋅下一个系列的教程中，我们会对上面这些知识有个逐步高级的应用，并增加markdown，页面静态化，nodejs的单元测试等，这块在upopen.cn的文章系统上已经应用。</p><p>⋅⋅⋅本部分的教程结束。谢谢！</p></div></section><div class="comments" name="comments" id="comments"><div class="commentWrap" id="commentWrap"></div><form class="commentForm" id="commentForm"><input type="text" placeholder="you name" id="commentUser" maxlength="30" class="commentUser"><br><textarea class="commentContent" id="commentContent" rows="6" maxlength="1000" placeholder="your comment for this blog within 1000 words"></textarea><br><button type="submit" id="commentBtn" class="btn">SAVE COMMENT</button><br><br></form></div></div> <% include ../../common/slide.ejs %> <% include ../../common/footer.ejs %>