<% include ../../common/header.ejs %>
<div class="main" id="blogBox">
	<section>	
		<div class="info clearfix">
			<span class="title">网页加载性能优化</span>
			<a class="type" href="/blog/list?kind=http">http</a>
			<img class="head" src="/public/imgs/head.png" width="42" />
		</div>
		<div class="tool">
			<!--span class="toolItem view">Views: 6</span>
			<span class="toolItem talk">Comments: 0</span-->
			<span class="toolItem date">Date: 2015-12-25</span>
		</div>
		<div class="content clearfix markdown"><p>从页面、运维、服务三方面整理这个问题</p>

<hr/>

<h4>一、页面端</h4>

<h5>1、优化html / css / js写法，此处和技术能力及开发习惯有关</h5>

<blockquote><p>如：</p><p>a、尽量减少DOM数量及层级，会增加dom计算量。</p><p>b、重绘对页面绘制效率影响较大，而重绘通常是因流式布局中dom的大小变化而造成的其后dom位置改变，所以对会影响DOM的样式前置加载。</p><p>c、src通过属性预先设置宽高，图片通常是置后显示的，提前定义大小可以减少重绘。</p><p>d、css避免使用通配符</p><p>e、css避免使用dom查找，如 ul li{}，而直接使用cass名，如.classLi{}</p><p>f、css避免使用多级查找如 ，div span ul li{}，直接用 .divSpanUlLi{}。因为css查找是自右至左的</p><p>g、css避免使用伪类，ie浏览器对此类样式渲染很慢</p><p>h、head中指明编码格式，浏览器每次获取数据，通常只能缓存1KB数据，若未能找到编码定义，则会用默认编码，后面再找到定义则需重新渲染。</p><p>g、当页面较长时，非当前屏的图片延后加载。</p><p>h、JS渲染dom时，在缓存内组装好且加好event，再一次性插入到页面。对有可能再次操作的dom，渲染前就在缓存里保留指针，以便再次访问时不需要到页面DOM里查找，该写对开发习惯有较高的要求。</p><p>i、独立将css / js 独立成文件，独立不仅会使页面代码更加清晰，其也会被浏览器缓存。</p><p>h、引用CSS时用link，不要后@import，后者不会被缓存</p><p>注：上面有些建议与实际开发效率相违背，不要教条，视情况采纳。</p></blockquote>

<h5>2、资源加载顺序</h5>

<blockquote><p>a、原则上影响页面初始html加载显示的都后置加载。</p><p>b、但若影响页面初建显示的css文件需放head里加载，以便不会使页面加载产生错乱，并且该部分的CSS后置会导致页面绘制回流，影响速度。CSS中不要使用expressions形式。</p><p>c、不会影响初始效果的css放页面底，如弹框等组件的CSS，通常不会初始显示，即使显示也是在页面加载完成，经过一些JS逻辑执行后。</p><p>d、JS文件放页面底部加载，JS使用模块化框架如requirejs，其不能提高速度，但能使代码更清晰，便于管控</p></blockquote>

<h4>3、减少http请求</h4>

<blockquote><p>使用uglify.js类框架合并、压缩JS / CSS文件，图片使用css sprites，对于一些常用的小图标用 inline images 及 iconfont</p></blockquote>

<h5>4、Ajax</h5>

<blockquote><p>a、对数据库查询量较大的数据使用异步ajax，减少返回等待时间。</p><p>b、数据请求尽量用get请求，其将请求附在url上， 服务端一次就可以从request.header中收到。post请求是在header之后在另行发送的。显然前者速度会更快。</p><p>c、另外get请求可以被缓存，对于数据较稳定的请求可以缓存ajax，但需要慎重，禁用缓存 $.ajaxSetup( { cache: false } );</p></blockquote>

<h5>5、减少cookie，每次http请求都会自动将cookie带到后台，增加传输文件量。比较极致的方案，是静态资源跨域名存放，跨域名请求时不会带cookie，但JS文件会产生跨域的问题。另外浏览器对cookie大小限制在4kb以内。</h5>

<hr/>

<h4>二、运维</h4>

<h5>1、缓存</h5>

<blockquote><p>设置缓存静态资源，js / css /imgs等，以便用户再次访问时，可以读取本地文件。不过要设置良好的更新机制，可以设置cache的 expires 到指定日期，但因站点信息的变动时间不确定，为避免服务器资源已修改，而客户端仍用旧文件的情况，可以通过为静态资源文件加时间戳的形式。</p></blockquote>

<h5>2、Gzip压缩</h5>

<blockquote><p>nginx开启Gzip压缩，通过设置压缩比，可明显的减小数据传送</p></blockquote>

<h5>3、CDN技术，部署成本较大，现在已经有很多成熟的CDN服务商，会依据请求方地址，就近加载。</h5>

<h5>4、静态资源多个域名部署</h5>

<blockquote><p>浏览器对同一域名的并发请求通常为2-4个，静态资源部署在不同域名的服务器上增加并发数。</p></blockquote>

<hr/>

<h4>三、服务端</h4>

<h5>1、对可能会出现的并发接口提供组合，如某模块显示资源需从不同的表多次分开请求获取，对于此类，应请求组合接口，以便一次请求即可获取需要的数据</h5>

<hr/>

<h4>四、手机</h4>

<h5>1、单个文件小于25K，部分手机对超过25K的文件不会缓存</h5></div>
	</section>
	<div class="comments">
		<div class="commentWrap" id="commentWrap">
			
		</div>
		<form class="commentForm" id="commentForm">
			<input type="text" placeHolder="you name" id="commentUser" maxLength="30" class="commentUser" /><br />
			<textarea class="commentContent" id="commentContent" rows="6" maxLength="1000" placeHolder="your comment for this blog within 1000 words"></textarea><br />
			<button type="submit" id="commentBtn" class="btn">SAVE COMMENT</button><br /><br />
		</form>
	</div>
</div>

<% include ../../common/slide.ejs %>
<% include ../../common/footer.ejs %>
